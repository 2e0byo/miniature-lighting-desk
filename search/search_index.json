{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Quickstart \u00a4 plug the lighting controller in to the computer, and turn it on. install the backend: bash python3 -m pip install miniature-lighting-desk lighting_desk backend enter the server password when prompted. go to https://2e0byo.github.io/lighting-desk .","title":"Quickstart"},{"location":"#quickstart","text":"plug the lighting controller in to the computer, and turn it on. install the backend: bash python3 -m pip install miniature-lighting-desk lighting_desk backend enter the server password when prompted. go to https://2e0byo.github.io/lighting-desk .","title":"Quickstart"},{"location":"changelog/","text":"","title":"Changelog"},{"location":"installation/","text":"The backend \u00a4 is deployed on pypi . To install it you need a recent python (>=3.9) installed, and then you can run in a terminal: python3 -m pip install miniature-lighting-desk or, if you prefer to use pipx (note that it will not be possible to use the scripting interface if you install with pipx): pipx install miniature-lighting-desk When the server is installed, it needs to be started. You run it in a terminal with: lighting_desk server The local frontend \u00a4 is installed with the server. You run it with: lighting_desk local-gui Server development \u00a4 Clone this repository, and then run poetry install poetry shell Frontend development \u00a4 Clone 2e0byo/lighting-desk and then run cd lighting-desk yarn install yarn serve Contributing \u00a4 Open a Pull Request.","title":"Installation"},{"location":"installation/#the-backend","text":"is deployed on pypi . To install it you need a recent python (>=3.9) installed, and then you can run in a terminal: python3 -m pip install miniature-lighting-desk or, if you prefer to use pipx (note that it will not be possible to use the scripting interface if you install with pipx): pipx install miniature-lighting-desk When the server is installed, it needs to be started. You run it in a terminal with: lighting_desk server","title":"The backend"},{"location":"installation/#the-local-frontend","text":"is installed with the server. You run it with: lighting_desk local-gui","title":"The local frontend"},{"location":"installation/#server-development","text":"Clone this repository, and then run poetry install poetry shell","title":"Server development"},{"location":"installation/#frontend-development","text":"Clone 2e0byo/lighting-desk and then run cd lighting-desk yarn install yarn serve","title":"Frontend development"},{"location":"installation/#contributing","text":"Open a Pull Request.","title":"Contributing"},{"location":"license/","text":"``` MIT License Copyright (c) 2021 2e0byo Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. ```","title":"License"},{"location":"overview/","text":"Your miniature lighting controller is controlled over USB, using a custom (but very simple ad documented) protocol. USB is a good way to control hardware: it is ubiquitous it is fast it has high reliability (inbuilt packet error checking) Unfortunately, USB requires wires. When you are running around a studio, it would be nice to be able to control the controller from anywhere: via an app via a web browser via software running on the computer connected (via USB) to the controller. miniature-lighting-desk exists to make this possible. It provides a server which communicates with a miniature controller over USB (leveraging the same code shipped with the original miniature-lighting-controller ) and with various frontend clients. This server can handle multiple connections, locally and over a network. Network and local frontends are supplied (although the local frontend is now deprecated, and no further development will be done.** The backend \u00a4 runs on a computer connected to the controller. This computer does not need to be a standard \u2018computer\u2019: it could be a Raspberry Pi, a wireless router (running something like openwrt ), anything. The only requirement is that it can run the server, i.e. it needs a recent python and a network connection. The local frontend \u00a4 is identical to the previous software. It is provided for familiarity. No further development will be done on it, as the web frontend is also useable locally. Once miniature-lighting-desk is installed you can run it directly: bash lighting_desk local Note that only one of the backend or the local frontend can control the controller at any one time. The local frontend is provided only as a backup, particularly as it needs no internet connection to work. The web frontend \u00a4 is written in Vue.js and looks a great deal better than the old frontend. Functionality can be added to it very easily without affecting the backend server.","title":"Overview"},{"location":"overview/#the-backend","text":"runs on a computer connected to the controller. This computer does not need to be a standard \u2018computer\u2019: it could be a Raspberry Pi, a wireless router (running something like openwrt ), anything. The only requirement is that it can run the server, i.e. it needs a recent python and a network connection.","title":"The backend"},{"location":"overview/#the-local-frontend","text":"is identical to the previous software. It is provided for familiarity. No further development will be done on it, as the web frontend is also useable locally. Once miniature-lighting-desk is installed you can run it directly: bash lighting_desk local Note that only one of the backend or the local frontend can control the controller at any one time. The local frontend is provided only as a backup, particularly as it needs no internet connection to work.","title":"The local frontend"},{"location":"overview/#the-web-frontend","text":"is written in Vue.js and looks a great deal better than the old frontend. Functionality can be added to it very easily without affecting the backend server.","title":"The web frontend"},{"location":"extending/hardware/","text":"Hardware \u00a4 Mains Dimming \u00a4 It would be possible to add a trailing-edge mosfet dimmer to functions like a standard dimmer switch. Contact me if you want to do this. Multiple Voltages \u00a4 It would be possible to add another voltage regulator inside to drive some channels, so that they could be controlled in, say, two groups. But if you need to do this a lot (and can\u2019t use the trick above), it would be better to build another controller, which would probably be about as much work. Parallel outputs? \u00a4 What if you want more current? You can theoretically run two outputs in parallel, as they switch at the same time, but you should be careful to make sure they really do have the same value all the time. This would be quite easy if we were scripting, we could do something like: ```python def set_parallel_output(brightness): output_one.set_brightness(brightness) output_two.set_brightness(brightness) set_parallel_output(128) ``` where output_one and output_two are already defined, like red_lamp etc in the scripting section. Alternatively you could have one slider control multiple outputs. Have a go at implementing this if you want it, but ask me if you need help. Paralleling more than two outputs is probably a bad idea. What are you tring to drive which needs so much current? It would be possible (and easier) just to modify the hardware to use a beefier MOSFET. They are very cheap. A nicer case! \u00a4 Yes, the case is really not of the best. It was made in the freezing cold in a great hurry. Since you now have a 3D printer, perhaps you would like to make a better one?","title":"Hardware"},{"location":"extending/hardware/#hardware","text":"","title":"Hardware"},{"location":"extending/hardware/#mains-dimming","text":"It would be possible to add a trailing-edge mosfet dimmer to functions like a standard dimmer switch. Contact me if you want to do this.","title":"Mains Dimming"},{"location":"extending/hardware/#multiple-voltages","text":"It would be possible to add another voltage regulator inside to drive some channels, so that they could be controlled in, say, two groups. But if you need to do this a lot (and can\u2019t use the trick above), it would be better to build another controller, which would probably be about as much work.","title":"Multiple Voltages"},{"location":"extending/hardware/#parallel-outputs","text":"What if you want more current? You can theoretically run two outputs in parallel, as they switch at the same time, but you should be careful to make sure they really do have the same value all the time. This would be quite easy if we were scripting, we could do something like: ```python def set_parallel_output(brightness): output_one.set_brightness(brightness) output_two.set_brightness(brightness) set_parallel_output(128) ``` where output_one and output_two are already defined, like red_lamp etc in the scripting section. Alternatively you could have one slider control multiple outputs. Have a go at implementing this if you want it, but ask me if you need help. Paralleling more than two outputs is probably a bad idea. What are you tring to drive which needs so much current? It would be possible (and easier) just to modify the hardware to use a beefier MOSFET. They are very cheap.","title":"Parallel outputs?"},{"location":"extending/hardware/#a-nicer-case","text":"Yes, the case is really not of the best. It was made in the freezing cold in a great hurry. Since you now have a 3D printer, perhaps you would like to make a better one?","title":"A nicer case!"},{"location":"extending/software/","text":"Example: a \u2018zero\u2019 button \u00a4 Take a look at gui.py . First open it and then save it under a new name, so we can go back and retrieve the original if need be. Call the new name gui2.py . We are going to add a \u2018zero\u2019 button which zeros every channel. For this we need a function which zeros channels. After the lines python for i in range(8): channels.append(ChannelSlider(i, master)) add the following: python def zero(): \"\"\"Zero everything.\"\"\" for channel in channels: channel.set(0) Now we need a button to call this function. After: python save_button = Button(master, text=\"Save State\", command=save_state) save_button.grid(column=8 - 3, row=3) add: python zero_button = Button(master, text=\"Zero\", command=zero) zero_button.grid(column=0, row=3) save it and run. Now you have a zero button. Excercise: a \u2018max\u2019 button Can you implemenet another button, to set every channel to the maximum? Hint: look at the specifications above (or the source code for the HAL) to find out what the maximum is , numerically. Harder Excercise: a master slider What if you wanted a \u2019master\u2019 slider, which let you set the brightness of all the channels? Assume that you want the slider to function as a multiplier (i.e. it doesn\u2019t actually move the other channels, but they get multiplier by it before the controller is set.) This will require editing the definition of ChannelSlider . I personally would just edit the set method. Perhaps something like: python def set(self, val): self.channel.set_brightness(int(float(val) * master_slider.get() / 100)) self.slider.set(int(float(val))) and then define master slider as something like: python master_slider = Scale(master, from_=100, to=0, length=300, orient=\"horizontal\") and place it below the other sliders. Get in touch if you try this and have problems: I\u2019ve only provided the outline here.","title":"Software"},{"location":"extending/software/#example-a-zero-button","text":"Take a look at gui.py . First open it and then save it under a new name, so we can go back and retrieve the original if need be. Call the new name gui2.py . We are going to add a \u2018zero\u2019 button which zeros every channel. For this we need a function which zeros channels. After the lines python for i in range(8): channels.append(ChannelSlider(i, master)) add the following: python def zero(): \"\"\"Zero everything.\"\"\" for channel in channels: channel.set(0) Now we need a button to call this function. After: python save_button = Button(master, text=\"Save State\", command=save_state) save_button.grid(column=8 - 3, row=3) add: python zero_button = Button(master, text=\"Zero\", command=zero) zero_button.grid(column=0, row=3) save it and run. Now you have a zero button. Excercise: a \u2018max\u2019 button Can you implemenet another button, to set every channel to the maximum? Hint: look at the specifications above (or the source code for the HAL) to find out what the maximum is , numerically. Harder Excercise: a master slider What if you wanted a \u2019master\u2019 slider, which let you set the brightness of all the channels? Assume that you want the slider to function as a multiplier (i.e. it doesn\u2019t actually move the other channels, but they get multiplier by it before the controller is set.) This will require editing the definition of ChannelSlider . I personally would just edit the set method. Perhaps something like: python def set(self, val): self.channel.set_brightness(int(float(val) * master_slider.get() / 100)) self.slider.set(int(float(val))) and then define master slider as something like: python master_slider = Scale(master, from_=100, to=0, length=300, orient=\"horizontal\") and place it below the other sliders. Get in touch if you try this and have problems: I\u2019ve only provided the outline here.","title":"Example: a \u2018zero\u2019 button"},{"location":"implementation/docs/","text":"It\u2019s bad practice to ship code without documentation aimed at other coders. Thus this section is technical. Overview HAL \u00a4 The controller interacted with using a Controller() object provided by the hal. Only the asyncio hal is developed. The expectation is that code will not be primarily asyncio-based, so the Controller() object starts its own asyncio thread and manages it. Communication is by Bulk transfers, and is not awaitable (since AFAIK pyusb isn\u2019t awaitable yet). In any case it\u2019s so fast we don\u2019t need to worry. In point of fact we merely await delays in various fade steps. On initialisation the Controller object starts an asyncio thread, grabs the usb device (specifically: the first it finds, so if we need to control multiple devices we\u2019ll have to edit it to accept a bus/dev manually) and then waits. It provides a submit_async method which must be used to run awaitables, returning a futures. The Channel() object represents a distinct channel on the controller. It takes a Controller object as an argument. On initialisation it queries the hardware for the current channel value. It then keeps track of this locally, except when an asynchronous fade is cancelled, when it queries again to discover what has actually happend. It provides methods to get and set brightness, either as a raw number or a percentage (float between 0.0 and 1.0), and asynchronous fade_on and fade_off methods, as well as cancel_fade to cancel a running fade. Note that precision in timing is not promised with these methods, and userspace fading should be done where precision matters. Note also that the Channel() class is wholly synchronous: it merely submits tasks to the Controller() which in turn submits them to its asyncio thread. If multiple controllers are desired, the code should probably be extended to enable sharing this asyncio event loop. Overview GUI \u00a4 I am not a gui programmer. This is a very simple gui in tkinter. It uses ttk (Themed Tkinter) for slightly better-looking graphics. A ChannelSlider class both creates the tkinter.ttk.Scale object which draws the slider and the async_hal.Channel object which controls it. Then we have a getter and setter. The getter just returns the slider value; the setter sets both the Channel by calling set_brightness and the slider. We cast to float and then int since ttk returns float strings but tk int strings (at least in my testing), and to show how it\u2019s done. State is handled with single line csvs consisting of nothing more than than the channel values as ints. Further details \u00a4 See the code, it\u2019s very simple.","title":"Documentation"},{"location":"implementation/docs/#overview-hal","text":"The controller interacted with using a Controller() object provided by the hal. Only the asyncio hal is developed. The expectation is that code will not be primarily asyncio-based, so the Controller() object starts its own asyncio thread and manages it. Communication is by Bulk transfers, and is not awaitable (since AFAIK pyusb isn\u2019t awaitable yet). In any case it\u2019s so fast we don\u2019t need to worry. In point of fact we merely await delays in various fade steps. On initialisation the Controller object starts an asyncio thread, grabs the usb device (specifically: the first it finds, so if we need to control multiple devices we\u2019ll have to edit it to accept a bus/dev manually) and then waits. It provides a submit_async method which must be used to run awaitables, returning a futures. The Channel() object represents a distinct channel on the controller. It takes a Controller object as an argument. On initialisation it queries the hardware for the current channel value. It then keeps track of this locally, except when an asynchronous fade is cancelled, when it queries again to discover what has actually happend. It provides methods to get and set brightness, either as a raw number or a percentage (float between 0.0 and 1.0), and asynchronous fade_on and fade_off methods, as well as cancel_fade to cancel a running fade. Note that precision in timing is not promised with these methods, and userspace fading should be done where precision matters. Note also that the Channel() class is wholly synchronous: it merely submits tasks to the Controller() which in turn submits them to its asyncio thread. If multiple controllers are desired, the code should probably be extended to enable sharing this asyncio event loop.","title":"Overview HAL"},{"location":"implementation/docs/#overview-gui","text":"I am not a gui programmer. This is a very simple gui in tkinter. It uses ttk (Themed Tkinter) for slightly better-looking graphics. A ChannelSlider class both creates the tkinter.ttk.Scale object which draws the slider and the async_hal.Channel object which controls it. Then we have a getter and setter. The getter just returns the slider value; the setter sets both the Channel by calling set_brightness and the slider. We cast to float and then int since ttk returns float strings but tk int strings (at least in my testing), and to show how it\u2019s done. State is handled with single line csvs consisting of nothing more than than the channel values as ints.","title":"Overview GUI"},{"location":"implementation/docs/#further-details","text":"See the code, it\u2019s very simple.","title":"Further details"},{"location":"implementation/firmware/","text":"The code is somewhat tricky to read, as it is hacked together from the Pinguino original (Pinguino uses simple \u2018sketches\u2019 to generate a large number of files which are then compiled to produce the machine-code running on the microcontroller), but the core routine is simple enough: ```c receivedbyte = BULK_read(buffer); / returns index of end / unsigned char channel; unsigned long duty; inputPTR = buffer; if (!strncmp(inputPTR, \u201cs\u201d, 1)) { channel = ascii_to_decimal(inputPTR[1]); duty = 100 ascii_to_decimal(inputPTR[2]) + 10 ascii_to_decimal(inputPTR[3]) + ascii_to_decimal(inputPTR[4]); if (duty>256) duty = 256; newDuties[channel] = duty; BULK_printf(\u201cSet channel %u to %u\u201d, channel, duty); } else if (!strncmp(inputPTR, \u201cg\u201d, 1)) { BULK_printf(\u201cChannel %u is %u\u201d, channel, newDuties[channel]); } ``` This is in C, which is harder than python, at any rate to read as a non-coder. I\u2019ve also cut all the error detection and a few other things: see pic/user.c if you want to see the whole thing. This code, which runs in a loop which otherwise sits around waiting for data, looks to see if the input (obtained by calling BULK_read ) starts with \u2018s\u2019, and if so, Sets the given channel to the value given (after converting it from ascii to decimal, i.e. from a string like \"4\" to the number 4 ), makes sure it\u2019s no bigger than 256, and then writes the new value to an array, newDuties . This array is checked by the interrupt routine which happens very quickly, thousands of times a second, and which, in simplified form, looks like this: c ++count; unsigned char latch = LATD; if (count == 0) { latch = 0; for (unsigned char i=0; i<8; i++) { duties[i] = newDuties[i]; } } for (unsigned char i=0; i<8; i++) { if (duties[i] == count) latch |= (0x1 << i); } LATD = latch; Firstly we update a variable \u2018count\u2019. This variable is defined elsewhere as being only 8 bits long, i.e. the maximum value it can store is (2^8 -1 = 255). If we try to add one to it when it stores 255, it will \u2018roll over\u2019 to 0 again, which is handy. So we have 255 steps. Then we set a temporary variable to the value of LATD , which is the value of the 8-bit output port controlling the channels, or, in simple terms, the value of the channels. So if LATD is \u201811110000\u2019, channels 0-3 will be off, and 4-7 will be on (note: numbers are right-to-left when written down!). We store this in a variable, since writing to LATD changes the actual outputs , which is pretty nifty. Then, only if count is \u20180\u2019, we set the temporary \u2018latch\u2019 variable to 0 (i.e. all channels off), and set the \u2018duties\u2019 array to be the same as the \u2018newduties\u2019 we modified earlier. We don\u2019t modify \u2018duties\u2019 directly to avoid flickering, which would happen if we updated \u2018duties\u2019 halfway through a cycle. Then we go through each channel in turn, and if the value of count is the same as the value of duties[i] (that is: the ith value in the array duties ) turn the ith channel on. (This is what the weird thing with the << does: it sets the ith bit of our \u2018latch\u2019 variable.) Note that we start by turning outputs off , and turn them on when we get to the value transmitted. So to turn a channel off you send 256, which is 1 more than 255 and so will never cause it to be turned on. This is the reason for the weird resolution\u2014255 steps - 1 to turn it fully off = 256 steps. The HAL turns this round for you, so set_brightness(256) is full on and set_brightness(0) is off, as you would expect. This is another reason to use a HAL. Then, finally, we set the real output to be whatever we have assembled in our temporary latch variable.","title":"Firmware"},{"location":"implementation/hardware/","text":"A circuit diagram is provided, since it\u2019s a good idea to have such things: Note that the voltage regulator is not shown: this is a module, bought from Amazon or Ebay ages ago, and is switch-mode (so it shouldn\u2019t get too hot). I have no idea of its specifications, but the worst case scenario\u2014300mA on each channel, or 8x300 = 2.4A is probably pushing it. The core of the hardware is a PIC18f4550 microcontroller, a small one-chip computer running at 12MHz (compare that to your laptop, running probably at several GHz). It has integrated USB hardware, and is running the Pinguino bootloader, which allows updating the firmware over usb. The circuit is simplicity itself. The outputs from the PIC are either at 0v or at 5v. They are connected to 2n7000 mosfets, which are in this usage like switches, which turn on if 5v is applied to the gate and off if 0v is applied. They don\u2019t like handling more than a few hundred mA, though, so bigger mosfet switches might be needed if you wanted to switch more.","title":"Hardware"},{"location":"scripting/more/","text":"There, that was easy! Let\u2019s take another look at demo.py. Here is the beginning again: ```python from math import pi, sin from time import sleep import async_hal as hal # hal = Hardware Abstraction Layer lighting_controller = hal.Controller() red_lamp = hal.Channel(lighting_controller, 7) white_lamp = hal.Channel(lighting_controller, 0) set brightness in background \u00a4 red_lamp.set_brightness(0) ``` Anything after a # is a \u2018comment\u2019, i.e. it\u2019s for you, not the computer, which just ignores it. The first two lines \u2018import\u2019 things from \u2018libraries\u2019\u2014i.e. \u2018other code\u2019. The \u2018math\u2019 library is built into Python, and provides mathematical functions and constants (obviously). The time library, amazingly enough, provides things to do with time, and is likewise built in. async_hal is a library I wrote, distributed with the demo. It\u2019s called async hal as I first wrote a synchronous hal, but then abandoned it as the async one is much better. (It sends the usb requests in the background.) A hal is a Hardware Abstraction Layer, i.e. something which does the hard work of talking to the hardware. This hal provides a class , which is a way of assigning representations to objects\u2014in this case the physical object in front of you. From your point of view it\u2019s just a function which returns an \u2018object\u2019, which we call lighting_controller . Once we have an object representing the controller, we make an object for each of the channels: python red_lamp = hal.Channel(lighting_controller, 7) The Channel class in the hall represents a channel on a controller . So you have to tell it which controller. We only have one: the one we just made a representation of! We also need to know which channel on the \u2018hardware\u2019 correlates with this channel on the \u2018software\u2019: here\u2019s it\u2019s number 7. This is conceptually quite complicated, but very easy in practice. For instance, let\u2019s make a Channel object for the third channel. Remember we start counting at 0: python third_channel = hal.Channel(lighting_controller, 2) We could have called it something else. Perhaps we have a street lamp attached to channel 3: python street_lamp = hal.Channel(lighting_controller, 3) The name we give it is just a variable. It can contain pretty much anything, if we stick to the alphabet and the underscore ( _ ). Each channel object has few methods. Here they are: ```python white_lamp.set_brightness(128) white_lamp.set_percent_brightness(0.1) white_lamp.get_brightness() white_lamp.get_percent_brightness() white_lamp.fade_on(1) wait a second before typing \u00a4 white_lamp.fade_off(100) white_lamp.cancel_fade() ``` Additionally, when we initialise a Channel object it queries the controller for the current setting on that channel, so the software never gets out of sync with the hardware. (This is used in the gui to make the sliders all appear at the right place.) Going further \u00a4 Read the rest of demo.py . Can you see how it works?","title":"More Details"},{"location":"scripting/more/#set-brightness-in-background","text":"red_lamp.set_brightness(0) ``` Anything after a # is a \u2018comment\u2019, i.e. it\u2019s for you, not the computer, which just ignores it. The first two lines \u2018import\u2019 things from \u2018libraries\u2019\u2014i.e. \u2018other code\u2019. The \u2018math\u2019 library is built into Python, and provides mathematical functions and constants (obviously). The time library, amazingly enough, provides things to do with time, and is likewise built in. async_hal is a library I wrote, distributed with the demo. It\u2019s called async hal as I first wrote a synchronous hal, but then abandoned it as the async one is much better. (It sends the usb requests in the background.) A hal is a Hardware Abstraction Layer, i.e. something which does the hard work of talking to the hardware. This hal provides a class , which is a way of assigning representations to objects\u2014in this case the physical object in front of you. From your point of view it\u2019s just a function which returns an \u2018object\u2019, which we call lighting_controller . Once we have an object representing the controller, we make an object for each of the channels: python red_lamp = hal.Channel(lighting_controller, 7) The Channel class in the hall represents a channel on a controller . So you have to tell it which controller. We only have one: the one we just made a representation of! We also need to know which channel on the \u2018hardware\u2019 correlates with this channel on the \u2018software\u2019: here\u2019s it\u2019s number 7. This is conceptually quite complicated, but very easy in practice. For instance, let\u2019s make a Channel object for the third channel. Remember we start counting at 0: python third_channel = hal.Channel(lighting_controller, 2) We could have called it something else. Perhaps we have a street lamp attached to channel 3: python street_lamp = hal.Channel(lighting_controller, 3) The name we give it is just a variable. It can contain pretty much anything, if we stick to the alphabet and the underscore ( _ ). Each channel object has few methods. Here they are: ```python white_lamp.set_brightness(128) white_lamp.set_percent_brightness(0.1) white_lamp.get_brightness() white_lamp.get_percent_brightness() white_lamp.fade_on(1)","title":"set brightness in background"},{"location":"scripting/more/#wait-a-second-before-typing","text":"white_lamp.fade_off(100) white_lamp.cancel_fade() ``` Additionally, when we initialise a Channel object it queries the controller for the current setting on that channel, so the software never gets out of sync with the hardware. (This is used in the gui to make the sliders all appear at the right place.)","title":"wait a second before typing"},{"location":"scripting/more/#going-further","text":"Read the rest of demo.py . Can you see how it works?","title":"Going further"},{"location":"scripting/quick/","text":"The easiest way to start off is to open and edit the demo I have provided. So open demo.py in IDLE (Python\u2019s inbuilt editor) and let\u2019s have a look. It begins like this: ```python from math import pi, sin from time import sleep import async_hal as hal # hal = Hardware Abstraction Layer lighting_controller = hal.Controller() red_lamp = hal.Channel(lighting_controller, 7) white_lamp = hal.Channel(lighting_controller, 0) set brightness in background \u00a4 red_lamp.set_brightness(0) ``` Copy this much into a new file called quick_start.py and save it in the same place you found demo.py \u2014probably just on the usb stick. Then change the last line to read: python red_lamp.set_brightness(128) and press \u2018run\u2019. There. You wrote your first controlling script. The window which popped up when you pressed \u2018run\u2019 should still be open. Type into it: python red_lamp.set_percent_brightness(0.75) and observe what happens. Then press Ctrl-P: the line you just typed should appear. Change the 0.75 to 0.25. Press enter, and observe what happens. Press Ctrl-P, then press it again: do you see how it lets you go \u2018back\u2019 through your input? Replacing the \u2018p\u2019 with an \u2018n\u2019 lets you go \u2018forward\u2019. In this way you can do less typing. Try: python white_lamp.fade_on() Notice how the white lamps takes around a second to fade on, but the code returns immediately: it\u2019s fading in the background (\u2018asynchronously\u2019). This may or may not be what you want, depending on what you\u2019re trying to do.","title":"Quick Start"},{"location":"scripting/quick/#set-brightness-in-background","text":"red_lamp.set_brightness(0) ``` Copy this much into a new file called quick_start.py and save it in the same place you found demo.py \u2014probably just on the usb stick. Then change the last line to read: python red_lamp.set_brightness(128) and press \u2018run\u2019. There. You wrote your first controlling script. The window which popped up when you pressed \u2018run\u2019 should still be open. Type into it: python red_lamp.set_percent_brightness(0.75) and observe what happens. Then press Ctrl-P: the line you just typed should appear. Change the 0.75 to 0.25. Press enter, and observe what happens. Press Ctrl-P, then press it again: do you see how it lets you go \u2018back\u2019 through your input? Replacing the \u2018p\u2019 with an \u2018n\u2019 lets you go \u2018forward\u2019. In this way you can do less typing. Try: python white_lamp.fade_on() Notice how the white lamps takes around a second to fade on, but the code returns immediately: it\u2019s fading in the background (\u2018asynchronously\u2019). This may or may not be what you want, depending on what you\u2019re trying to do.","title":"set brightness in background"},{"location":"uses/concept/","text":"I imagined this functioning rather like a standard lighting controller, only for stopmotion sets, controlling one or two lights, as you did with batteries in Fydor. However it could handle more: for instance, a set of chritmas lights could be fashioned into streetlamps, and turn on fitfully, like real lamps lighting up, by scripting a \u2018turn on\u2019 program. If you weren\u2019t shooting in realtime but could control the camera from the computer, each step in the fitful turn-on could happen a few milliseconds before the shot is taken, saving you from setting the manually (although I imagine this kind of thing would probably be filmed in realtime). Likewise, it could be used just as something to play with: for several days it faded a string of lights on and off in a sinusoidal pattern in the living room. If you want, it would be possible to add the ability to store patterns (of a limitied duration). It could also be used for more exotic setups: one could attach a relay controlling a mains light to a channel, although one could only turn it on and off (and care must be taken when dealing with mains electricity!). It could drive some kinds of motors with speed control. It could drive small heating elements, though what you\u2019d want small heating elements for I don\u2019t know. Lastly, if you get bored, learning to program it is a fair introduction to coding in Python, an easy and very versatile language which is used everywhere.","title":"Concept"},{"location":"uses/uses/","text":"Uses \u00a4 This is a lighting controller, exactly like lighting controllers in a theatre. It has eight channels, numbered 0-7 (since I am a lazy programmer, and computers start counting at 0). These can be set between off (0) and full on (256\u2014no, that\u2019s not a typo, see implementation/hardware to find out why). At 0 the corresponding pair of output terminals has no voltage accross it. At 256 it has the voltage displayed on the little display accross it. This voltage can be adjusted by turning the knob, but it applies to all channels (so you can only really control lamps or outputs which want the same voltage accross them, although see multiple outputs .) You can drive standard filament lamps\u2014the kind you\u2019ve used before\u2014directly. You can also drive some LEDs directly, and others with an appropriate current limiting resistor (see LEDs ). You could also theoretically drive any other resistive sink, or indeed an inductive sink like a motor, as protection diodes are fitted. The controller (the hardware) is controlled over USB, by a computer running software. It ships with two demo programs: a graphical program consisting of eight sliders which can be used to control the channels, exactly like a \u2018real\u2019 theatre controller, together with the ability to load and save states, for use as presets, and a demonstration of scripting the controller, which is discussed in Scripting . The controller is powered by an external SMPSU, which sometimes gets a little warm in operation, but which is capable of running for extended periods wtihout overheating. The SMPSU can supply up to 30v, but is set to supply 15v at the moment, which is probably all you want to handle. Each channel can provide around 300mA, which should be enough for all realistic uses.","title":"Uses"},{"location":"uses/uses/#uses","text":"This is a lighting controller, exactly like lighting controllers in a theatre. It has eight channels, numbered 0-7 (since I am a lazy programmer, and computers start counting at 0). These can be set between off (0) and full on (256\u2014no, that\u2019s not a typo, see implementation/hardware to find out why). At 0 the corresponding pair of output terminals has no voltage accross it. At 256 it has the voltage displayed on the little display accross it. This voltage can be adjusted by turning the knob, but it applies to all channels (so you can only really control lamps or outputs which want the same voltage accross them, although see multiple outputs .) You can drive standard filament lamps\u2014the kind you\u2019ve used before\u2014directly. You can also drive some LEDs directly, and others with an appropriate current limiting resistor (see LEDs ). You could also theoretically drive any other resistive sink, or indeed an inductive sink like a motor, as protection diodes are fitted. The controller (the hardware) is controlled over USB, by a computer running software. It ships with two demo programs: a graphical program consisting of eight sliders which can be used to control the channels, exactly like a \u2018real\u2019 theatre controller, together with the ability to load and save states, for use as presets, and a demonstration of scripting the controller, which is discussed in Scripting . The controller is powered by an external SMPSU, which sometimes gets a little warm in operation, but which is capable of running for extended periods wtihout overheating. The SMPSU can supply up to 30v, but is set to supply 15v at the moment, which is probably all you want to handle. Each channel can provide around 300mA, which should be enough for all realistic uses.","title":"Uses"},{"location":"uses/using/","text":"Connect to Computer. Plug in power supply. Set correct voltage. Attach lamps etc. to each channel. Load software. If you have any trouble connecting to the controller (after installing the software), turn it off and on again whilst still plugged in to the computer. Connnections \u00a4 Connections are by screw-terminal (chocolate block). Try not to sort the outputs (for instance by stripping too much insulation off the end of the wires). LEDs \u00a4 LEDs can be driven, but need more care than filament lamps. In general LEDs should be driven in constant current mode, not constant voltage . This is because, although they have a constant threshold voltage (the voltage, or rather narrow range of voltages, at which they start glowing), they represent a very low-resistance load above this voltage (effectively a short circuit). Thus as the voltage climbs they absorb a lot of power and catch fire. This is inverse to the behaviour of a filament lamp, which is effectively a short circuit when connected, but rapidly gains in resistance as it heats up, and so consumes less and less power until it reaches a stable state. If driven with a constant current of the right amount, LEDs will operate at the correct voltage. Thus, when a given current is put through them, they have a given, fixed voltage accross them. We can take advantage of this to drive them with a series resistor. According to Ohm\u2019s Law, (V=IR), so (I=V/R). V is fixed, but we can change R. For an LED with a working voltage of 2.5v at 10mA (or 0.01A), with the controller set to 6V, the voltage accross the resistor will be (6-2.5=3.5), and the resistor needs to be (R=V/I = 3.5/0.01 = 350 \\Omega). They don\u2019t make 350 ohm resistors, so pick the next largest: 390. This value is rather high, but I made these numbers up. What about the christmas lights? They have no resistor at all! Another set I bought did use a series resistor, but in this case the manufacturer has paralleled all the LEDs, and matched them so well that they share current equally. (It\u2019s quite easy when you make them in the hundreds of thousands). Thus they represent one big LED. This big LED sinks a lot more current than a single LED\u2014most only sink a few mA and can be blown up by a few tens of mA. These all sink about 30mA. Moreover, they have a working voltage of 3v. If we go slightly above the working voltage with a standard LED we supply a lot more current than it can take. But if we do so with these, we have more room for error. Also, we actually do have a series resistor\u2014the controller\u2019s internal resistance! I estimate this to be in the order of several ohms, perhaps even 10 ohms. It is largely caused by the switiching MOSFETs on-resistance (see Hardware ). TL;DR \u00a4 If this sounds like a lot maths: most leds can be driven with a 150\u03a9 resistor from 5v without any problems. Note that they only conduct one way. If you want to drive from a higher voltage, scale the resistor appropriately. The supplied red LED is a \u2018high brightness\u2019 kind (i.e. it turns on early) and is in series with a 1k (1,000\u03a9) resistor, which makes it safe at least up to 15v, but it still turns on appreciably at 3! I wanted it to be hard for you to blow it up. Christmas lights can generally be driven as in the original. If there is no series resistor, you don\u2019t need one either. If there is a series resistor, you can simply cut it out and use it, setting the controller to the same voltage. Differing Voltages \u00a4 What do you do if you want to control two lamps of different voltage ratings at the same time? You might think that you could use e.g. a 6v and a 12v lamp at the same time, by never taking the 6v channel above 50%. And so you can\u2014with a caveat: the controller uses PWM (Pulse Width Modulation) to adjust the effective output voltages, i.e. it switches on and off very fast. So the lamps need to be able to survive a pulse at the maximum brightness. Filament lamps are fine about this, and LEDs often are. Note that in this case the resolution of the lower lamp is reduced\u2014i.e. if you have a 6V light never driven above 50%, there are only 128 steps, not 256. Limitations \u00a4 The hardware has a latency: it cannot switch instantaneously. This is likely not a problem, but could be if you try very high-frame rate filming. It is possible the switching frequency could create aliasing effects with the shutter speed, although I highly doubt it. In this case contact about changing it.","title":"Using"},{"location":"uses/using/#connnections","text":"Connections are by screw-terminal (chocolate block). Try not to sort the outputs (for instance by stripping too much insulation off the end of the wires).","title":"Connnections"},{"location":"uses/using/#leds","text":"LEDs can be driven, but need more care than filament lamps. In general LEDs should be driven in constant current mode, not constant voltage . This is because, although they have a constant threshold voltage (the voltage, or rather narrow range of voltages, at which they start glowing), they represent a very low-resistance load above this voltage (effectively a short circuit). Thus as the voltage climbs they absorb a lot of power and catch fire. This is inverse to the behaviour of a filament lamp, which is effectively a short circuit when connected, but rapidly gains in resistance as it heats up, and so consumes less and less power until it reaches a stable state. If driven with a constant current of the right amount, LEDs will operate at the correct voltage. Thus, when a given current is put through them, they have a given, fixed voltage accross them. We can take advantage of this to drive them with a series resistor. According to Ohm\u2019s Law, (V=IR), so (I=V/R). V is fixed, but we can change R. For an LED with a working voltage of 2.5v at 10mA (or 0.01A), with the controller set to 6V, the voltage accross the resistor will be (6-2.5=3.5), and the resistor needs to be (R=V/I = 3.5/0.01 = 350 \\Omega). They don\u2019t make 350 ohm resistors, so pick the next largest: 390. This value is rather high, but I made these numbers up. What about the christmas lights? They have no resistor at all! Another set I bought did use a series resistor, but in this case the manufacturer has paralleled all the LEDs, and matched them so well that they share current equally. (It\u2019s quite easy when you make them in the hundreds of thousands). Thus they represent one big LED. This big LED sinks a lot more current than a single LED\u2014most only sink a few mA and can be blown up by a few tens of mA. These all sink about 30mA. Moreover, they have a working voltage of 3v. If we go slightly above the working voltage with a standard LED we supply a lot more current than it can take. But if we do so with these, we have more room for error. Also, we actually do have a series resistor\u2014the controller\u2019s internal resistance! I estimate this to be in the order of several ohms, perhaps even 10 ohms. It is largely caused by the switiching MOSFETs on-resistance (see Hardware ).","title":"LEDs"},{"location":"uses/using/#tldr","text":"If this sounds like a lot maths: most leds can be driven with a 150\u03a9 resistor from 5v without any problems. Note that they only conduct one way. If you want to drive from a higher voltage, scale the resistor appropriately. The supplied red LED is a \u2018high brightness\u2019 kind (i.e. it turns on early) and is in series with a 1k (1,000\u03a9) resistor, which makes it safe at least up to 15v, but it still turns on appreciably at 3! I wanted it to be hard for you to blow it up. Christmas lights can generally be driven as in the original. If there is no series resistor, you don\u2019t need one either. If there is a series resistor, you can simply cut it out and use it, setting the controller to the same voltage.","title":"TL;DR"},{"location":"uses/using/#differing-voltages","text":"What do you do if you want to control two lamps of different voltage ratings at the same time? You might think that you could use e.g. a 6v and a 12v lamp at the same time, by never taking the 6v channel above 50%. And so you can\u2014with a caveat: the controller uses PWM (Pulse Width Modulation) to adjust the effective output voltages, i.e. it switches on and off very fast. So the lamps need to be able to survive a pulse at the maximum brightness. Filament lamps are fine about this, and LEDs often are. Note that in this case the resolution of the lower lamp is reduced\u2014i.e. if you have a 6V light never driven above 50%, there are only 128 steps, not 256.","title":"Differing Voltages"},{"location":"uses/using/#limitations","text":"The hardware has a latency: it cannot switch instantaneously. This is likely not a problem, but could be if you try very high-frame rate filming. It is possible the switching frequency could create aliasing effects with the shutter speed, although I highly doubt it. In this case contact about changing it.","title":"Limitations"}]}